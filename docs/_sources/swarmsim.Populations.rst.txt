Populations Package
===================

The Populations package defines various agent population models with different behavioral patterns
and dynamics. Each population type implements specific movement patterns, interaction rules,
and physical properties suitable for different simulation scenarios.

.. automodule:: swarmsim.Populations
   :members:
   :undoc-members:
   :show-inheritance:

Package Overview
----------------

Population models in SwarmSim provide:

* **Diverse Behavioral Models**: From simple random motion to complex multi-physics dynamics
* **Scalable Implementations**: Efficient algorithms for large populations
* **Configurable Properties**: Flexible parameter settings for different scenarios
* **Integration Support**: Seamless integration with integrators and interactions
* **Physical Realism**: Scientifically grounded models for various domains

All population classes inherit from the base population interface, ensuring consistent
integration with other simulation components.

Core Modules
------------

Base Population Interface
~~~~~~~~~~~~~~~~~~~~~~~~~

The foundation class that defines the standard interface for all population implementations.

.. automodule:: swarmsim.Populations.population
   :members:
   :undoc-members:
   :show-inheritance:

Key Features:

- **Standardized Interface**: Consistent API across all population types
- **State Management**: Handle agent positions, velocities, and properties
- **Integration Support**: Compatible with various numerical integrators
- **Scalable Architecture**: Efficient for populations from tens to millions of agents

Brownian Motion Population
~~~~~~~~~~~~~~~~~~~~~~~~~~

Implementation of Brownian motion dynamics for stochastic agent behavior.

.. automodule:: swarmsim.Populations.brownian_motion
   :members:
   :undoc-members:
   :show-inheritance:

Key Features:

- **Stochastic Dynamics**: Random motion with configurable noise intensity
- **Temperature Control**: Thermal energy effects on agent motion
- **Drift Capabilities**: Directional bias in random motion
- **Multi-dimensional Support**: 1D, 2D, and 3D motion simulation

Applications:
- Molecular dynamics simulation
- Animal foraging behavior
- Financial market modeling
- Diffusion processes

Simple Integrator Population
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Agent populations with first-order (velocity-based) dynamics.

.. automodule:: swarmsim.Populations.simple_integrators
   :members:
   :undoc-members:
   :show-inheritance:

Key Features:

- **First-order Dynamics**: Position directly controlled by velocity
- **Lightweight Implementation**: Minimal computational overhead
- **Direct Control**: Immediate response to control inputs
- **Ideal for Basic Simulations**: Perfect for proof-of-concept studies

Applications:
- Basic flocking simulations
- Simple robot coordination
- Traffic flow modeling
- Social dynamics studies

Double Integrator Population
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Agent populations with second-order (acceleration-based) dynamics.

.. automodule:: swarmsim.Populations.double_integrators
   :members:
   :undoc-members:
   :show-inheritance:

Key Features:

- **Second-order Dynamics**: Realistic inertial behavior
- **Force-based Control**: Control through acceleration/force inputs
- **Momentum Conservation**: Physically realistic motion patterns
- **Advanced Dynamics**: Support for complex mechanical behaviors

Applications:
- Robotic system simulation
- Vehicle dynamics modeling
- Spacecraft coordination
- Physical system simulation

Fixed Population
~~~~~~~~~~~~~~~~

Static agent populations for environment elements and obstacles.

.. automodule:: swarmsim.Populations.fixed_population
   :members:
   :undoc-members:
   :show-inheritance:

Key Features:

- **Static Positions**: Agents remain at fixed locations
- **Environmental Elements**: Represent obstacles, landmarks, or resources
- **Interaction Sources**: Provide forces/interactions without moving
- **Computational Efficiency**: No integration required

Applications:
- Environmental obstacles
- Resource locations
- Sensor networks
- Infrastructure elements

Persistent Turning Walker
~~~~~~~~~~~~~~~~~~~~~~~~~

Specialized population model for correlated random walks with turning behavior.

.. automodule:: swarmsim.Populations.parsistent_turning_walker
   :members:
   :undoc-members:
   :show-inheritance:

Key Features:

- **Correlated Motion**: Non-Markovian random walks
- **Turning Dynamics**: Realistic directional changes
- **Persistence Control**: Adjustable correlation in movement direction
- **Biological Realism**: Models animal movement patterns

Applications:
- Animal tracking and behavior
- Biological cell movement
- Search and exploration strategies
- Navigation algorithm testing

Usage Examples
--------------

Basic Population Setup
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    from swarmsim.Populations import BrownianMotion, DoubleIntegrators
    import numpy as np
    
    # Create Brownian motion population
    brownian_pop = BrownianMotion(
        n=100,                    # Number of agents
        x_dim=2,                  # 2D simulation
        diffusion_coefficient=0.1, # Noise strength
        drift_velocity=np.array([0.1, 0.0])  # Slight rightward drift
    )
    
    # Create double integrator population
    double_int_pop = DoubleIntegrators(
        n=50,
        x_dim=3,                  # 3D simulation
        mass=1.0,                 # Agent mass
        damping=0.1               # Velocity damping
    )

Multi-Population Simulation
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    from swarmsim.Populations import (BrownianMotion, SimpleIntegrators, 
                                     FixedPopulation)
    import numpy as np
    
    # Create diverse population mix
    prey = BrownianMotion(n=200, x_dim=2, diffusion_coefficient=0.2)
    predators = SimpleIntegrators(n=10, x_dim=2, max_speed=2.0)
    obstacles = FixedPopulation(
        positions=np.array([[5, 5], [10, 10], [15, 5]]),  # Fixed obstacle locations
        x_dim=2
    )
    
    populations = [prey, predators, obstacles]

Population Parameter Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    from swarmsim.Populations import DoubleIntegrators
    from swarmsim.Utils import get_parameters
    
    # Define parameter configuration
    param_config = {
        'mode': 'generate',
        'generate': {
            'mass': {
                'sampler': 'lognormal',
                'args': {'mean': 0, 'sigma': 0.3}  # Mass variation
            },
            'max_force': {
                'sampler': 'uniform',
                'args': {'low': 0.5, 'high': 2.0}  # Force limits
            }
        }
    }
    
    # Generate diverse parameters
    params = get_parameters(
        param_config,
        {'mass': (), 'max_force': ()},
        num_samples=100
    )
    
    # Create population with diverse properties
    population = DoubleIntegrators(
        n=100,
        x_dim=2,
        mass=params['mass'],
        max_force=params['max_force']
    )

Advanced Population Dynamics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    from swarmsim.Populations import PersistentTurningWalker
    import numpy as np
    
    # Create realistic animal movement model
    animal_population = PersistentTurningWalker(
        n=50,
        x_dim=2,
        step_length=0.1,           # Average step size
        turning_angle_std=0.3,     # Turning variability
        persistence_time=10.0,     # Correlation time
        boundary_behavior='reflect' # Boundary handling
    )
    
    # Simulate foraging behavior
    for step in range(1000):
        # Animals move with correlated random walks
        animal_population.step()
        
        # Add environmental responses
        if step % 100 == 0:
            # Occasional strong turning (predator response)
            animal_population.add_turning_bias(angle=np.pi/2, strength=2.0)

Population Interactions
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    from swarmsim.Populations import SimpleIntegrators
    from swarmsim.Interactions import LennardJones
    
    # Create interacting populations
    fish_school = SimpleIntegrators(n=100, x_dim=2)
    
    # Add inter-agent interactions
    interaction = LennardJones(
        epsilon=1.0,    # Interaction strength
        sigma=1.0,      # Interaction range
        cutoff=3.0      # Computational cutoff
    )
    
    # Simulation with interactions
    for step in range(1000):
        # Compute interaction forces
        forces = interaction.compute_forces(fish_school.x)
        
        # Apply forces and integrate
        fish_school.apply_forces(forces)
        fish_school.step()

Performance Optimization
------------------------

Population implementations are optimized for performance:

- **Vectorized Operations**: Extensive use of NumPy for computational efficiency
- **Memory Management**: Efficient memory layouts for large populations
- **Adaptive Algorithms**: Computational complexity scales appropriately
- **Parallel Support**: Compatible with parallel processing frameworks

Model Selection Guide
---------------------

Choose population models based on your simulation requirements:

.. list-table:: Population Model Selection
   :header-rows: 1
   :widths: 20 25 25 30

   * - Model Type
     - Computational Cost
     - Physical Realism
     - Best Applications
   * - Brownian Motion
     - Very Low
     - Moderate
     - Diffusion, stochastic processes
   * - Simple Integrators
     - Low
     - Low-Moderate
     - Basic flocking, rapid prototyping
   * - Double Integrators
     - Moderate
     - High
     - Robotics, vehicle dynamics
   * - Fixed Population
     - Minimal
     - N/A
     - Environmental elements
   * - Turning Walker
     - Low-Moderate
     - High (biological)
     - Animal behavior, search patterns

Best Practices
--------------

1. **Model Selection**: Choose the simplest model that captures essential behaviors
2. **Parameter Tuning**: Use biologically or physically realistic parameter ranges
3. **Population Size**: Balance realism with computational requirements
4. **Integration**: Ensure compatibility with chosen integrator and time step
5. **Validation**: Compare simulation results with theoretical or experimental data






